<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>AcadBird - Messages</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css"
    />

    <link rel="stylesheet" href="../style/messages_parents.css" />
  </head>
  <body>
    <div class="container">
      <!-- Navbar -->
      <nav class="navbar">
        <div class="logo">
          <img
            src="../../main/img/AcadBird - White no text.png"
            class="logo-img"
            alt="AcadBird Logo"
          />
          <img
            src="../../main/img/AcadBird - White Text.png"
            class="logo-text-img"
            alt="AcadBird Text"
          />Parent
        </div>
        <img
          src="../../main/img/sunhill.png"
          alt="AcadBird"
          class="middle-logo"
        />

        <div class="nav-icons">
          <div class="notification-wrapper">
            <a href="notification_parent.html">
              <img
                src="../../main/img/Notification.png"
                alt="Notifications"
                class="icon"
              />
              <span class="notification-badge" id="notificationBadge">0</span>
            </a>
          </div>
          <a href="help_parent.html">
            <img src="../../main/img/Help.png" alt="Help" class="icon" />
          </a>
          <a href="account_parent.html">
            <div class="account-menu">
              <img
                src="../../main/img/account icon.png"
                alt="User Account"
                class="icon"
              />
            </div>
          </a>
        </div>
      </nav>

      <div id="loading-overlay">
        <div class="loader-3">
          <div class="circle"></div>
          <div class="circle"></div>
          <div class="circle"></div>
          <div class="circle"></div>
          <div class="circle"></div>
        </div>
      </div>
    </div>

    <!-- Secondary Header -->
    <div class="secondary-header">
      <nav class="nav-menu">
        <a href="homepage_parents.html" class="nav-item">Home</a>
        <a href="dashboard_parents.html" class="nav-item">Dashboard</a>
        <a href="activitylog_parents.html" class="nav-item">Announcements</a>
        <a href="resources_parents.html" class="nav-item">Resources</a>
        <a href="messages_parents.html" class="nav-item active">Messages</a>
        <a href="account_parent.html" class="nav-item">Settings</a>
      </nav>
    </div>
    <div class="separator"></div>

    <!-- Main Messenger -->
    <div class="main-content">
      <div class="messages-card">
        <div class="messages-container">
          <div class="sidebar">
            <button class="new-message">
              <i class="fas fa-plus"></i> New message
            </button>
            <div class="sidebar-title">MOST RECENT</div>
            <ul class="chat-list">
              <!-- Dynamic content will be loaded here -->
              <div class="loading-chats">Loading conversations...</div>
            </ul>
          </div>

          <div class="chat-window">
            <div class="chat-header">
              <span id="chat-name">Select a conversation</span>
              <span id="chat-student">Choose a contact to start messaging</span>
            </div>
            <div class="chat-body" id="chat-body">
              <div class="welcome-message">
                <i class="fas fa-comments"></i>
                <h3>Welcome to Messages</h3>
                <p>
                  Select a contact from the sidebar to start a conversation.
                </p>
              </div>
            </div>
            <div class="chat-input">
              <i class="fas fa-paperclip attach"></i>
              <input
                type="text"
                id="message-input"
                placeholder="Select a conversation to message"
              />
              <button id="send-btn"><i class="fas fa-paper-plane"></i></button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- New Message Modal -->
    <div id="new-message-modal" class="modal">
      <div class="modal-content">
        <span class="close-btn">&times;</span>
        <h3>Select a Recipient</h3>
        <ul class="recipient-list">
          <!-- Dynamic content will be loaded here -->
          <div class="loading-recipients">Loading recipients...</div>
        </ul>
      </div>
    </div>

    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
      import {
        getFirestore,
        collection,
        query,
        where,
        getDocs,
        doc,
        getDoc,
        onSnapshot,
        addDoc,
        orderBy,
        serverTimestamp,
        updateDoc,
        writeBatch, // Add this import
      } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js";
      import {
        getAuth,
        onAuthStateChanged,
      } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";

      import { firebaseConfig } from "../../main/js/firebaseConfig.js";

      const app = initializeApp(firebaseConfig);
      const db = getFirestore(app);
      const auth = getAuth(app);

      const loadingOverlay = document.getElementById("loading-overlay");

      function showLoading() {
        loadingOverlay.style.display = "flex";
      }

      function hideLoading() {
        loadingOverlay.style.display = "none";
      }

      // Chat Service - Updated to match your database structure

      // Chat Service - Updated to fetch only current student's classroom participants
      const ChatService = {
        currentUser: null,
        studentIds: [],
        classroomIds: [],
        currentClassroomId: null, // Track the current classroom ID
        unsubscribeListeners: [],
        currentChatId: null,
        unreadCounts: new Map(),

        async init() {
          return new Promise((resolve) => {
            onAuthStateChanged(auth, async (user) => {
              if (user) {
                this.currentUser = user;
                await this.loadStudentIds();
                await this.loadClassroomIds();
                await this.determineCurrentClassroom(); // NEW: Determine current classroom
                await this.loadChatList();
                await this.setupChatListeners();
                resolve();
              } else {
                resolve();
              }
            });
          });
        },

        async loadStudentIds() {
          try {
            const currentStudentId = await this.getCurrentStudentId();
            if (currentStudentId) {
              this.studentIds = [currentStudentId];
              console.log("Loaded current student ID:", this.studentIds[0]);
            } else {
              console.log("No current student ID found");
              this.studentIds = [];
            }
          } catch (error) {
            console.error("Error loading student IDs:", error);
            this.studentIds = [];
          }
        },

        async getCurrentStudentId() {
          return localStorage.getItem("currentStudentId");
        },

        async loadClassroomIds() {
          this.classroomIds = new Set();
          try {
            for (const studentId of this.studentIds) {
              const studentDoc = await getDoc(doc(db, "students", studentId));
              if (studentDoc.exists()) {
                const studentData = studentDoc.data();
                if (studentData.classroomId) {
                  this.classroomIds.add(studentData.classroomId);
                }
              }
            }
            this.classroomIds = Array.from(this.classroomIds);
            console.log("Loaded classroom IDs:", this.classroomIds);
          } catch (error) {
            console.error("Error fetching classroom IDs:", error);
            this.classroomIds = [];
          }
        },

        // NEW FUNCTION: Determine the current classroom ID
        async determineCurrentClassroom() {
          try {
            // Get the current student's classroom
            if (this.studentIds.length > 0) {
              const currentStudentId = this.studentIds[0];
              const studentDoc = await getDoc(
                doc(db, "students", currentStudentId),
              );
              if (studentDoc.exists()) {
                const studentData = studentDoc.data();
                this.currentClassroomId = studentData.classroomId;
                console.log("Current classroom ID:", this.currentClassroomId);
              } else {
                console.log("Current student document not found");
                this.currentClassroomId = null;
              }
            } else {
              console.log("No student IDs available");
              this.currentClassroomId = null;
            }
          } catch (error) {
            console.error("Error determining current classroom:", error);
            this.currentClassroomId = null;
          }
        },

        async getChatParticipants() {
          const participants = [];

          try {
            console.log("Getting chat participants for current classroom...");

            // Only get teacher from current classroom
            if (this.currentClassroomId) {
              console.log(
                "Processing current classroom:",
                this.currentClassroomId,
              );
              const classroomDoc = await getDoc(
                doc(db, "classrooms", this.currentClassroomId),
              );
              if (classroomDoc.exists()) {
                const classroomData = classroomDoc.data();
                console.log("Classroom data:", classroomData);

                // Get teacher info
                if (classroomData.teacherId) {
                  console.log("Found teacher ID:", classroomData.teacherId);
                  const teacherDoc = await getDoc(
                    doc(db, "users", classroomData.teacherId),
                  );
                  if (teacherDoc.exists()) {
                    const teacherData = teacherDoc.data();
                    console.log("Teacher data:", teacherData);

                    // Only add if user is a teacher
                    if (teacherData.role === "teacher") {
                      participants.push({
                        id: classroomData.teacherId,
                        name:
                          `${teacherData.firstName} ${teacherData.lastName}`.trim() ||
                          "Teacher",
                        type: "teacher",
                        classroomId: this.currentClassroomId,
                        classroomName:
                          classroomData.classroomName || "Classroom",
                      });
                    }
                  } else {
                    console.log(
                      "Teacher document not found for ID:",
                      classroomData.teacherId,
                    );
                  }
                }
              } else {
                console.log(
                  "Classroom document not found for ID:",
                  this.currentClassroomId,
                );
              }

              // Get other parents from the current classroom
              console.log(
                "Looking for parents in current classroom:",
                this.currentClassroomId,
              );
              const studentsQuery = query(
                collection(db, "students"),
                where("classroomId", "==", this.currentClassroomId),
              );

              const studentsSnapshot = await getDocs(studentsQuery);
              console.log(
                `Found ${studentsSnapshot.size} students in classroom`,
              );

              for (const studentDoc of studentsSnapshot.docs) {
                const studentData = studentDoc.data();
                console.log("Student data:", studentData);

                let parentId = studentData.parentId;

                // Get parent info (excluding current parent)
                if (parentId && parentId !== this.currentUser.uid) {
                  console.log("Found parent ID:", parentId);
                  const parentDoc = await getDoc(doc(db, "users", parentId));
                  if (parentDoc.exists()) {
                    const parentData = parentDoc.data();
                    console.log("Parent data:", parentData);

                    // Only add if user is actually a parent
                    if (parentData.role === "parent") {
                      // Check if parent already added
                      const existingParent = participants.find(
                        (p) => p.id === parentId && p.type === "parent",
                      );

                      if (!existingParent) {
                        participants.push({
                          id: parentId,
                          name:
                            `${parentData.firstName} ${parentData.lastName}`.trim() ||
                            "Parent",
                          type: "parent",
                          studentName:
                            `${studentData.firstName} ${studentData.lastName}`.trim() ||
                            "Student",
                          classroomId: this.currentClassroomId,
                          classroomName:
                            studentData.classroomName || "Classroom",
                        });
                      }
                    }
                  } else {
                    console.log("Parent document not found for ID:", parentId);
                  }
                }
              }
            } else {
              console.log("No current classroom ID available");
            }
          } catch (error) {
            console.error("Error loading chat participants:", error);
          }

          console.log(
            "Final participants list (current classroom only):",
            participants,
          );
          return participants;
        },

        // Update getOrCreateChatId to use current classroom
        async getOrCreateChatId(participantId) {
          try {
            // Check if chat already exists
            const chatsAsParentQuery = query(
              collection(db, "chats"),
              where("parentId", "==", this.currentUser.uid),
              where("teacherId", "==", participantId),
            );

            const chatsAsTeacherQuery = query(
              collection(db, "chats"),
              where("teacherId", "==", this.currentUser.uid),
              where("parentId", "==", participantId),
            );

            const [chatsAsParentSnapshot, chatsAsTeacherSnapshot] =
              await Promise.all([
                getDocs(chatsAsParentQuery),
                getDocs(chatsAsTeacherQuery),
              ]);

            // Check if chat exists where current user is parent
            if (!chatsAsParentSnapshot.empty) {
              console.log(
                "Found existing chat as parent:",
                chatsAsParentSnapshot.docs[0].id,
              );
              return chatsAsParentSnapshot.docs[0].id;
            }

            // Check if chat exists where current user is teacher
            if (!chatsAsTeacherSnapshot.empty) {
              console.log(
                "Found existing chat as teacher:",
                chatsAsTeacherSnapshot.docs[0].id,
              );
              return chatsAsTeacherSnapshot.docs[0].id;
            }

            // Create new chat - determine if current user is parent or teacher
            const participantDoc = await getDoc(
              doc(db, "users", participantId),
            );
            let chatData = {};

            if (participantDoc.exists()) {
              const participantData = participantDoc.data();

              if (participantData.role === "teacher") {
                // Current user is parent, participant is teacher
                chatData = {
                  parentId: this.currentUser.uid,
                  teacherId: participantId,
                  classroomId: this.currentClassroomId || "", // Use current classroom ID
                  createdAt: serverTimestamp(),
                  lastMessage: "",
                  lastMessageTime: serverTimestamp(),
                };
              } else if (participantData.role === "parent") {
                // Current user is parent, participant is parent
                const userDoc = await getDoc(
                  doc(db, "users", this.currentUser.uid),
                );
                const userData = userDoc.data();

                if (userData.role === "parent") {
                  chatData = {
                    parentId1: this.currentUser.uid,
                    parentId2: participantId,
                    classroomId: this.currentClassroomId || "", // Use current classroom ID
                    createdAt: serverTimestamp(),
                    lastMessage: "",
                    lastMessageTime: serverTimestamp(),
                    type: "parent-parent",
                  };
                }
              }
            }

            console.log("Creating new chat with participant:", participantId);
            const chatRef = await addDoc(collection(db, "chats"), chatData);
            console.log("Created new chat:", chatRef.id);
            return chatRef.id;
          } catch (error) {
            console.error("Error getting/creating chat:", error);
            return null;
          }
        },

        // Update unread message count for a chat
        updateUnreadCount(chatId, snapshot) {
          let unreadCount = 0;

          snapshot.forEach((doc) => {
            const message = doc.data();
            // Count messages that are unread and not sent by current user
            if (!message.read && message.senderId !== this.currentUser.uid) {
              unreadCount++;
            }
          });

          // Store the unread count
          this.unreadCounts.set(chatId, unreadCount);

          // Update the badge in the sidebar
          this.updateChatBadge(chatId, unreadCount);
        },

        // Update badge in sidebar for a specific chat
        updateChatBadge(chatId, unreadCount) {
          const chatItem = document.querySelector(
            `.chat-item[data-chat-id="${chatId}"]`,
          );
          if (chatItem) {
            let badge = chatItem.querySelector(".unread-badge");

            if (!badge) {
              // Create badge if it doesn't exist
              badge = document.createElement("div");
              badge.className = "unread-badge";
              chatItem.appendChild(badge);
            }

            if (unreadCount > 0) {
              badge.textContent = unreadCount > 99 ? "99+" : unreadCount;
              badge.style.display = "flex";
            } else {
              badge.style.display = "none";
            }
          }
        },

        updateChatUI(chatId, participant, snapshot) {
          const chatBody = document.getElementById("chat-body");
          const activeChat = document.querySelector(".chat-item.active");

          // Only update if this is the active chat
          if (activeChat && activeChat.dataset.chatId === chatId) {
            chatBody.innerHTML = "";

            snapshot.forEach((doc) => {
              const message = doc.data();
              const messageDiv = document.createElement("div");
              messageDiv.className = `message ${message.senderId === this.currentUser.uid ? "sent" : "received"}`;

              // Create message content WITHOUT sender name
              const messageContent = document.createElement("div");
              messageContent.className = "message-content";
              messageContent.textContent = message.text;

              messageDiv.appendChild(messageContent);
              chatBody.appendChild(messageDiv);
            });

            chatBody.scrollTop = chatBody.scrollHeight;
          }
        },

        async sendMessage(chatId, messageText) {
          try {
            if (!messageText.trim()) return;

            // Get current user's name for the message
            const userDoc = await getDoc(
              doc(db, "users", this.currentUser.uid),
            );
            const userData = userDoc.exists() ? userDoc.data() : {};
            const senderName =
              `${userData.firstName} ${userData.lastName}`.trim() || "User";

            const messageData = {
              text: messageText.trim(),
              senderId: this.currentUser.uid,
              senderName: senderName,
              timestamp: serverTimestamp(),
              read: false,
            };

            // Add message to subcollection
            await addDoc(
              collection(db, "chats", chatId, "messages"),
              messageData,
            );

            // Update chat last message
            await updateDoc(doc(db, "chats", chatId), {
              lastMessage: messageText.trim(),
              lastMessageTime: serverTimestamp(),
            });
          } catch (error) {
            console.error("Error sending message:", error);
          }
        },

        async loadExistingChats() {
          try {
            const existingChats = [];

            // Get chats where current user is parent
            const parentChatsQuery = query(
              collection(db, "chats"),
              where("parentId", "==", this.currentUser.uid),
            );

            const parentChatsSnapshot = await getDocs(parentChatsQuery);

            for (const chatDoc of parentChatsSnapshot.docs) {
              const chatData = chatDoc.data();
              if (chatData.teacherId) {
                // This is a parent-teacher chat
                const teacherDoc = await getDoc(
                  doc(db, "users", chatData.teacherId),
                );
                if (teacherDoc.exists()) {
                  const teacherData = teacherDoc.data();
                  existingChats.push({
                    chatId: chatDoc.id,
                    participantId: chatData.teacherId,
                    name: `${teacherData.firstName} ${teacherData.lastName}`.trim(),
                    type: "teacher",
                    classroomId: chatData.classroomId,
                    classroomName: "Classroom",
                  });
                }
              }
            }

            // Get chats where current user is teacher (if applicable)
            const teacherChatsQuery = query(
              collection(db, "chats"),
              where("teacherId", "==", this.currentUser.uid),
            );

            const teacherChatsSnapshot = await getDocs(teacherChatsQuery);

            for (const chatDoc of teacherChatsSnapshot.docs) {
              const chatData = chatDoc.data();
              if (chatData.parentId) {
                // This is a teacher-parent chat
                const parentDoc = await getDoc(
                  doc(db, "users", chatData.parentId),
                );
                if (parentDoc.exists()) {
                  const parentData = parentDoc.data();
                  // Find the student for this parent
                  const studentsQuery = query(
                    collection(db, "students"),
                    where("parentId", "==", chatData.parentId),
                  );
                  const studentsSnapshot = await getDocs(studentsQuery);
                  let studentName = "Student";
                  if (!studentsSnapshot.empty) {
                    const studentData = studentsSnapshot.docs[0].data();
                    studentName =
                      `${studentData.firstName} ${studentData.lastName}`.trim();
                  }

                  existingChats.push({
                    chatId: chatDoc.id,
                    participantId: chatData.parentId,
                    name: `${parentData.firstName} ${parentData.lastName}`.trim(),
                    type: "parent",
                    studentName: studentName,
                    classroomId: chatData.classroomId,
                    classroomName: "Classroom",
                  });
                }
              }
            }

            return existingChats;
          } catch (error) {
            console.error("Error loading existing chats:", error);
            return [];
          }
        },

        async loadChatList() {
          // Load both existing chats and potential participants
          const [existingChats, participants] = await Promise.all([
            this.loadExistingChats(),
            this.getChatParticipants(),
          ]);

          const chatList = document.querySelector(".chat-list");

          console.log("Existing chats:", existingChats);
          console.log("Potential participants:", participants);

          chatList.innerHTML = "";

          // Add existing chats first
          for (const chat of existingChats) {
            const chatItem = this.createChatItem(chat);
            chatList.appendChild(chatItem);
          }

          // Add potential participants that don't have existing chats
          for (const participant of participants) {
            const existingChat = existingChats.find(
              (chat) => chat.participantId === participant.id,
            );
            if (!existingChat) {
              const chatId = await this.getOrCreateChatId(participant.id);
              if (chatId) {
                const chatItem = this.createChatItem({
                  chatId: chatId,
                  participantId: participant.id,
                  name: participant.name,
                  type: participant.type,
                  studentName: participant.studentName,
                  classroomName: participant.classroomName,
                });
                chatList.appendChild(chatItem);
              }
            }
          }

          if (chatList.children.length === 0) {
            chatList.innerHTML =
              '<div class="no-chats">No chat participants found</div>';
            return;
          }

          // Add click event listeners
          this.attachChatItemListeners();

          // Auto-select first chat if available
          const firstChat = chatList.querySelector(".chat-item");
          if (firstChat) {
            firstChat.classList.add("active");
            this.switchToChat(
              firstChat.dataset.chatId,
              firstChat.dataset.name,
              firstChat.dataset.type,
              firstChat.dataset.studentName,
              firstChat.dataset.classroomName,
            );
          }
        },

        createChatItem(chatData) {
          const chatItem = document.createElement("li");
          chatItem.className = "chat-item";
          chatItem.dataset.chatId = chatData.chatId;
          chatItem.dataset.participantId = chatData.participantId;
          chatItem.dataset.name = chatData.name;
          chatItem.dataset.type = chatData.type;
          chatItem.dataset.studentName = chatData.studentName || "";
          chatItem.dataset.classroomName = chatData.classroomName || "";

          chatItem.innerHTML = `
      <div class="avatar"></div>
      <div class="chat-info">
          <div class="chat-name">${chatData.name}</div>
          <div class="chat-sub">
              ${
                chatData.type === "teacher"
                  ? `Teacher - ${chatData.classroomName}`
                  : `Parent - ${chatData.studentName}'s parent`
              }
          </div>
      </div>
      <div class="unread-badge" style="display: none;">0</div>
    `;

          return chatItem;
        },

        attachChatItemListeners() {
          const chatItems = document.querySelectorAll(".chat-item");

          chatItems.forEach((item) => {
            item.addEventListener("click", () => {
              chatItems.forEach((i) => i.classList.remove("active"));
              item.classList.add("active");

              const chatId = item.dataset.chatId;
              const participantName = item.dataset.name;
              const participantType = item.dataset.type;
              const studentName = item.dataset.studentName;
              const classroomName = item.dataset.classroomName;

              this.switchToChat(
                chatId,
                participantName,
                participantType,
                studentName,
                classroomName,
              );
            });
          });
        },

        async markMessagesAsRead(chatId) {
          try {
            console.log("Marking messages as read for chat:", chatId);

            // Get ALL messages from this chat (we'll filter client-side)
            const messagesQuery = query(
              collection(db, "chats", chatId, "messages"),
              orderBy("timestamp", "asc"),
            );

            const messagesSnapshot = await getDocs(messagesQuery);

            // Filter unread messages client-side
            const unreadMessages = [];
            messagesSnapshot.forEach((doc) => {
              const message = doc.data();
              if (
                message.read === false &&
                message.senderId !== this.currentUser.uid
              ) {
                unreadMessages.push(doc.ref);
              }
            });

            console.log(
              `Found ${unreadMessages.length} unread messages to mark as read`,
            );

            if (unreadMessages.length === 0) {
              console.log("No unread messages found");
              return;
            }

            // Use batch write to mark all unread messages as read
            const batch = writeBatch(db);

            unreadMessages.forEach((messageRef) => {
              batch.update(messageRef, {
                read: true,
                readAt: serverTimestamp(),
              });
            });

            await batch.commit();
            console.log("Successfully marked messages as read");

            // Reset unread count for this chat
            this.unreadCounts.set(chatId, 0);
            this.updateChatBadge(chatId, 0);
          } catch (error) {
            console.error("Error marking messages as read:", error);
            // Even if Firestore update fails, update the UI state
            this.unreadCounts.set(chatId, 0);
            this.updateChatBadge(chatId, 0);
          }
        },

        async setupChatListeners() {
          // Clean up previous listeners
          this.unsubscribeListeners.forEach((unsubscribe) => unsubscribe());
          this.unsubscribeListeners = [];

          const participants = await this.getChatParticipants();

          // Set up listeners for each chat
          for (const participant of participants) {
            const chatId = await this.getOrCreateChatId(participant.id);

            if (chatId) {
              const messagesQuery = query(
                collection(db, "chats", chatId, "messages"),
                orderBy("timestamp", "asc"),
              );

              // First, get the current unread count
              const initialSnapshot = await getDocs(messagesQuery);
              this.updateUnreadCount(chatId, initialSnapshot);

              // Then set up real-time listener
              const unsubscribe = onSnapshot(messagesQuery, (snapshot) => {
                this.updateChatUI(chatId, participant, snapshot);
                this.updateUnreadCount(chatId, snapshot);
              });

              this.unsubscribeListeners.push(unsubscribe);
            }
          }
        },

        async debugChatState(chatId) {
          try {
            const messagesQuery = query(
              collection(db, "chats", chatId, "messages"),
              orderBy("timestamp", "asc"),
            );

            const messagesSnapshot = await getDocs(messagesQuery);
            console.log(`=== DEBUG Chat ${chatId} ===`);

            let totalMessages = 0;
            let unreadMessages = 0;

            messagesSnapshot.forEach((doc) => {
              totalMessages++;
              const message = doc.data();
              if (
                message.read === false &&
                message.senderId !== this.currentUser.uid
              ) {
                unreadMessages++;
                console.log(`UNREAD: ${message.text} from ${message.senderId}`);
              } else {
                console.log(
                  `READ: ${message.text} from ${message.senderId} (read: ${message.read})`,
                );
              }
            });

            console.log(`Total: ${totalMessages}, Unread: ${unreadMessages}`);
            console.log("=== END DEBUG ===");
          } catch (error) {
            console.error("Error debugging chat:", error);
          }
        },

        async switchToChat(
          chatId,
          participantName,
          participantType,
          studentName,
          classroomName,
        ) {
          const chatName = document.getElementById("chat-name");
          const chatStudent = document.getElementById("chat-student");
          const chatBody = document.getElementById("chat-body");
          const messageInput = document.getElementById("message-input");

          // Update header
          chatName.textContent = participantName;

          if (participantType === "teacher") {
            chatStudent.textContent = `Teacher - ${classroomName}`;
          } else {
            chatStudent.textContent = `Parent - ${studentName}'s parent`;
          }

          messageInput.placeholder = `Message ${participantName}`;

          // Clear and load messages
          chatBody.innerHTML = "Loading...";
          this.currentChatId = chatId;

          try {
            const messagesQuery = query(
              collection(db, "chats", chatId, "messages"),
              orderBy("timestamp", "asc"),
            );

            const messagesSnapshot = await getDocs(messagesQuery);
            chatBody.innerHTML = "";

            if (messagesSnapshot.empty) {
              chatBody.innerHTML =
                '<div class="no-messages">No messages yet. Start the conversation!</div>';
            } else {
              messagesSnapshot.forEach((doc) => {
                const message = doc.data();
                const messageDiv = document.createElement("div");
                messageDiv.className = `message ${message.senderId === this.currentUser.uid ? "sent" : "received"}`;

                // Create message content WITHOUT sender name
                const messageContent = document.createElement("div");
                messageContent.className = "message-content";
                messageContent.textContent = message.text;

                messageDiv.appendChild(messageContent);
                chatBody.appendChild(messageDiv);
              });
            }

            chatBody.scrollTop = chatBody.scrollHeight;

            // Mark messages as read when opening the chat
            await this.debugChatState(chatId);
            await this.markMessagesAsRead(chatId);
          } catch (error) {
            console.error("Error loading messages:", error);
            chatBody.innerHTML =
              '<div class="error">Error loading messages</div>';
          }
        },
      };

      const BadgeService = {
        currentUser: null,
        studentIds: [],

        async init() {
          return new Promise((resolve) => {
            onAuthStateChanged(auth, async (user) => {
              if (user) {
                this.currentUser = user;
                await this.loadStudentIds();
                await this.setupRealTimeListener();
                await this.updateBadgeCount();
                resolve();
              } else {
                resolve();
              }
            });
          });
        },

        async setupRealTimeListener() {
          if (this.studentIds.length === 0) return;

          // Listen for new activities
          this.studentIds.forEach((studentId) => {
            const activitiesQuery = query(
              collection(db, "activity"),
              where("studentID", "==", studentId),
            );

            onSnapshot(activitiesQuery, () => {
              this.updateBadgeCount();
            });
          });

          // Listen for new resources
          const classroomIds = await this.getClassroomIds();
          classroomIds.forEach((classroomId) => {
            const topicContentQuery = query(
              collection(db, "topicContent"),
              where("classroomID", "==", classroomId),
            );

            onSnapshot(topicContentQuery, () => {
              this.updateBadgeCount();
            });
          });
        },

        // In BadgeService
        async loadStudentIds() {
          try {
            // Use the same logic as ChatService to get current student
            const currentStudentId = await this.getCurrentStudentId();
            this.studentIds = currentStudentId ? [currentStudentId] : [];
            console.log(
              "BadgeService - Loaded current student ID:",
              this.studentIds[0],
            );
          } catch (error) {
            console.error("Error loading student IDs in BadgeService:", error);
            this.studentIds = [];
          }
        },

        async getCurrentStudentId() {
          return localStorage.getItem("currentStudentId");
        },
        async getClassroomIds() {
          const classroomIds = new Set();

          try {
            for (const studentId of this.studentIds) {
              const studentDoc = await getDoc(doc(db, "students", studentId));
              if (studentDoc.exists()) {
                const studentData = studentDoc.data();
                if (studentData.classroomId) {
                  classroomIds.add(studentData.classroomId);
                }
              }
            }
            console.log(
              "BadgeService - Loaded classroom IDs:",
              Array.from(classroomIds),
            );
          } catch (error) {
            console.error(
              "Error fetching classroom IDs in BadgeService:",
              error,
            );
          }

          return Array.from(classroomIds);
        },
        async getUnreadCount() {
          if (!this.currentUser || this.studentIds.length === 0) {
            return 0;
          }

          try {
            let unreadCount = 0;

            // Count unread activities
            for (const studentId of this.studentIds) {
              const activitiesQuery = query(
                collection(db, "activity"),
                where("studentID", "==", studentId),
              );

              const activitiesSnapshot = await getDocs(activitiesQuery);

              for (const activityDoc of activitiesSnapshot.docs) {
                const isRead = await this.checkIfRead(
                  activityDoc.id,
                  "activity",
                );
                if (!isRead) unreadCount++;
              }
            }

            // Count unread resources
            const classroomIds = await this.getClassroomIds();
            for (const classroomId of classroomIds) {
              const topicContentQuery = query(
                collection(db, "topicContent"),
                where("classroomID", "==", classroomId),
              );

              const topicContentSnapshot = await getDocs(topicContentQuery);

              for (const topicContentDoc of topicContentSnapshot.docs) {
                const topicContentData = topicContentDoc.data();
                const topicId = topicContentData.topicID;

                // Fetch topic doc
                const topicDocSnap = await getDoc(doc(db, "topic", topicId));
                if (!topicDocSnap.exists()) continue;
                const topicData = topicDocSnap.data();

                // Only count if topic is public
                if (topicData.status !== "public") continue;

                const isRead = await this.checkIfRead(
                  topicContentDoc.id,
                  "resource",
                );
                if (!isRead) unreadCount++;
              }
            }

            return unreadCount;
          } catch (error) {
            console.error("Error counting unread notifications:", error);
            return 0;
          }
        },

        async checkIfRead(itemId, type) {
          if (!itemId) return false;

          try {
            const fieldName = type === "activity" ? "activityId" : "resourceId";
            const notificationsQuery = query(
              collection(db, "notification"),
              where(fieldName, "==", itemId),
              where("parentId", "==", this.currentUser.uid),
            );

            const querySnapshot = await getDocs(notificationsQuery);
            return !querySnapshot.empty;
          } catch (error) {
            console.error("Error checking read status:", error);
            return false;
          }
        },

        async updateBadgeCount() {
          const badge = document.getElementById("notificationBadge");
          if (badge) {
            const count = await this.getUnreadCount();
            badge.textContent = count;
            badge.style.display = count > 0 ? "inline" : "none";
          }
        },
      };

      // Initialize everything
      // Initialize everything
      // Initialize everything with student selector
      document.addEventListener("DOMContentLoaded", async function () {
        showLoading();

        try {
          // Wait for authentication first
          const user = await getCurrentUser();

          if (!user) {
            console.error("No user logged in");
            hideLoading();
            return;
          }

          // Get all students for current user
          const students = await getStudentsForCurrentUser(user);

          if (students.length === 0) {
            console.error("No students found for current user");
            hideLoading();
            showError("No students found for your account.");
            return;
          }

          // If only one student, use it automatically
          if (students.length === 1) {
            const correctStudentId = students[0].id;
            localStorage.setItem("currentStudentId", correctStudentId);
            console.log("Single student found, using:", correctStudentId);
            await initializeMessagingApp(); // Renamed this function
          } else {
            // Multiple students - show selector
            await showStudentSelector(students);
          }
        } catch (error) {
          console.error("Error initializing:", error);
          hideLoading();
          showError("Error loading student information.");
        }
      });

      // Wait for authentication to be ready
      function getCurrentUser() {
        return new Promise((resolve) => {
          const auth = getAuth();

          // Check if user is already logged in
          const user = auth.currentUser;
          if (user) {
            resolve(user);
            return;
          }

          // Wait for auth state change
          const unsubscribe = onAuthStateChanged(auth, (user) => {
            unsubscribe();
            resolve(user);
          });

          // Timeout after 5 seconds
          setTimeout(() => {
            unsubscribe();
            resolve(null);
          }, 5000);
        });
      }

      async function getStudentsForCurrentUser(user) {
        try {
          if (!user) return [];

          const studentsQuery = query(
            collection(db, "students"),
            where("parentId", "==", user.uid),
          );

          const studentsSnapshot = await getDocs(studentsQuery);

          return studentsSnapshot.docs.map((doc) => ({
            id: doc.id,
            firstName: doc.data().firstName || "Unknown",
            lastName: doc.data().lastName || "Student",
            classroomName: doc.data().classroomName || "Classroom",
          }));
        } catch (error) {
          console.error("Error getting students:", error);
          return [];
        }
      }

      async function showStudentSelector(students) {
        // Create student selector UI
        const selectorHTML = `
    <div id="student-selector-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center; z-index: 10000; font-family: 'Poppins', sans-serif;">
      <div style="background: white; padding: 30px; border-radius: 15px; min-width: 400px; max-width: 90%; box-shadow: 0 10px 30px rgba(0,0,0,0.3);">
        <div style="text-align: center; margin-bottom: 20px;">
          <i class="fas fa-user-graduate" style="font-size: 3rem; color: #3498db; margin-bottom: 10px;"></i>
          <h3 style="margin: 10px 0 5px 0; color: #2c3e50;">Select Student</h3>
          <p style="color: #666; margin: 0;">Choose which student to view messages for</p>
        </div>
        
        <div style="margin: 20px 0;">
          <label for="student-select" style="display: block; margin-bottom: 8px; font-weight: 600; color: #2c3e50;">Student:</label>
          <select id="student-select" style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 16px; background: white; cursor: pointer; transition: border-color 0.3s;">
            ${students
              .map(
                (student) =>
                  `<option value="${student.id}">${student.firstName} ${student.lastName} - ${student.classroomName}</option>`,
              )
              .join("")}
          </select>
        </div>
        
        <button id="confirm-student" style="width: 100%; padding: 15px; background: #3498db; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; transition: background-color 0.3s;">
          <i class="fas fa-check"></i> Confirm Selection
        </button>
        
        <div style="margin-top: 15px; text-align: center;">
          <small style="color: #888;">You can change this later in settings</small>
        </div>
      </div>
    </div>
  `;

        document.body.insertAdjacentHTML("beforeend", selectorHTML);

        // Add hover effects
        const confirmBtn = document.getElementById("confirm-student");
        const studentSelect = document.getElementById("student-select");

        confirmBtn.addEventListener("mouseenter", () => {
          confirmBtn.style.backgroundColor = "#2980b9";
        });

        confirmBtn.addEventListener("mouseleave", () => {
          confirmBtn.style.backgroundColor = "#3498db";
        });

        studentSelect.addEventListener("focus", () => {
          studentSelect.style.borderColor = "#3498db";
        });

        studentSelect.addEventListener("blur", () => {
          studentSelect.style.borderColor = "#e0e0e0";
        });

        // Set initial selection if exists in localStorage
        const currentStudentId = localStorage.getItem("currentStudentId");
        if (
          currentStudentId &&
          students.find((s) => s.id === currentStudentId)
        ) {
          studentSelect.value = currentStudentId;
        }

        confirmBtn.addEventListener("click", async () => {
          const selectedStudentId = studentSelect.value;
          const selectedStudent = students.find(
            (s) => s.id === selectedStudentId,
          );

          localStorage.setItem("currentStudentId", selectedStudentId);
          console.log(
            "Selected student:",
            selectedStudent.firstName,
            selectedStudent.lastName,
          );

          // Add loading state to button
          confirmBtn.innerHTML =
            '<i class="fas fa-spinner fa-spin"></i> Loading...';
          confirmBtn.disabled = true;

          // Remove selector with fade effect
          const overlay = document.getElementById("student-selector-overlay");
          overlay.style.opacity = "0";
          overlay.style.transition = "opacity 0.3s";

          setTimeout(() => {
            overlay.remove();
            initializeMessagingApp(); // Renamed this function
          }, 300);
        });

        // Allow Enter key to confirm selection
        studentSelect.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            confirmBtn.click();
          }
        });
      }

      // Renamed this function to avoid conflict with Firebase initializeApp
      async function initializeMessagingApp() {
        showLoading();

        try {
          await BadgeService.init();
          await ChatService.init();

          // Setup send message functionality
          const sendBtn = document.getElementById("send-btn");
          const messageInput = document.getElementById("message-input");

          sendBtn.addEventListener("click", () => {
            if (ChatService.currentChatId && messageInput.value.trim()) {
              ChatService.sendMessage(
                ChatService.currentChatId,
                messageInput.value,
              );
              messageInput.value = "";
            }
          });

          messageInput.addEventListener("keydown", (e) => {
            if (
              e.key === "Enter" &&
              ChatService.currentChatId &&
              messageInput.value.trim()
            ) {
              ChatService.sendMessage(
                ChatService.currentChatId,
                messageInput.value,
              );
              messageInput.value = "";
            }
          });

          // Setup new message modal functionality
          const newMessageBtn = document.querySelector(".new-message");
          const newMessageModal = document.getElementById("new-message-modal");
          const modalCloseBtn = document.querySelector(".close-btn");
          const recipientList = document.querySelector(".recipient-list");

          newMessageBtn.addEventListener("click", async () => {
            newMessageModal.style.display = "block";

            // Load participants for modal
            const participants = await ChatService.getChatParticipants();
            recipientList.innerHTML = "";

            if (participants.length === 0) {
              recipientList.innerHTML =
                '<div class="no-recipients">No recipients available</div>';
              return;
            }

            participants.forEach((participant) => {
              const li = document.createElement("li");
              li.dataset.participantId = participant.id;
              li.dataset.name = participant.name;
              li.dataset.type = participant.type;
              li.dataset.studentName = participant.studentName || "";
              li.dataset.classroomName = participant.classroomName || "";

              li.innerHTML = `
            <span class="recipient-name">${participant.name}</span>
            <span class="recipient-info">
                ${
                  participant.type === "teacher"
                    ? `Teacher - ${participant.classroomName}`
                    : `Parent - ${participant.studentName}'s parent`
                }
            </span>
        `;

              recipientList.appendChild(li);
            });

            // Add click listeners to modal recipients
            recipientList.querySelectorAll("li").forEach((item) => {
              item.addEventListener("click", async () => {
                const participantId = item.dataset.participantId;
                const participantName = item.dataset.name;
                const participantType = item.dataset.type;
                const studentName = item.dataset.studentName;
                const classroomName = item.dataset.classroomName;

                const chatId =
                  await ChatService.getOrCreateChatId(participantId);

                // Find and click the corresponding chat item
                const chatItem = document.querySelector(
                  `.chat-item[data-participant-id="${participantId}"]`,
                );
                if (chatItem) {
                  chatItem.click();
                } else {
                  // If chat item doesn't exist yet, reload chat list
                  await ChatService.loadChatList();
                  const newChatItem = document.querySelector(
                    `.chat-item[data-participant-id="${participantId}"]`,
                  );
                  if (newChatItem) newChatItem.click();
                }

                newMessageModal.style.display = "none";
              });
            });
          });

          modalCloseBtn.addEventListener("click", () => {
            newMessageModal.style.display = "none";
          });

          window.addEventListener("click", (e) => {
            if (e.target === newMessageModal) {
              newMessageModal.style.display = "none";
            }
          });

          // Add student switcher to the UI
          addStudentSwitcher();
        } catch (error) {
          console.error("Error initializing app:", error);
          showError("Error loading messages. Please try again.");
        } finally {
          hideLoading();
        }
      }

      function addStudentSwitcher() {
        // Add a student switcher button to the header or sidebar
        const currentStudentId = localStorage.getItem("currentStudentId");
        if (!currentStudentId) return;

        // Create switcher button
        const switcherHTML = `
    <div class="student-switcher" style="margin: 10px 0; text-align: center;">
      <button id="switch-student-btn" style="background: #f8f9fa; border: 1px solid #e0e0e0; border-radius: 20px; padding: 8px 16px; font-size: 12px; color: #666; cursor: pointer; transition: all 0.3s;">
        <i class="fas fa-sync-alt"></i> Switch Student
      </button>
    </div>
  `;

        // Add to sidebar (you can change this location)
        const sidebar = document.querySelector(".sidebar");
        if (sidebar) {
          const newMessageBtn = sidebar.querySelector(".new-message");
          if (newMessageBtn) {
            newMessageBtn.insertAdjacentHTML("afterend", switcherHTML);

            document
              .getElementById("switch-student-btn")
              .addEventListener("click", () => {
                localStorage.removeItem("currentStudentId");
                location.reload();
              });
          }
        }
      }

      function showError(message) {
        const errorHTML = `
    <div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 10px; text-align: center; box-shadow: 0 5px 15px rgba(0,0,0,0.2); z-index: 10000;">
      <i class="fas fa-exclamation-triangle" style="font-size: 3rem; color: #e74c3c; margin-bottom: 15px;"></i>
      <h3 style="margin: 0 0 10px 0; color: #2c3e50;">Error</h3>
      <p style="color: #666; margin: 0 0 20px 0;">${message}</p>
      <button onclick="location.reload()" style="background: #3498db; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
        Try Again
      </button>
    </div>
  `;
        document.body.insertAdjacentHTML("beforeend", errorHTML);
      }

      // Add some CSS for better styling
      const style = document.createElement("style");
      style.textContent = `
  #student-selector-overlay {
    font-family: 'Poppins', sans-serif;
  }
  
  #confirm-student:hover {
    background-color: #2980b9 !important;
  }
  
  #student-select:focus {
    border-color: #3498db !important;
    outline: none;
  }
  
  .student-switcher button:hover {
    background: #e9ecef !important;
    border-color: #3498db !important;
    color: #3498db !important;
  }
`;
      document.head.appendChild(style); // New Message Modal functionality
      document.addEventListener("DOMContentLoaded", () => {
        const newMessageBtn = document.querySelector(".new-message");
        const newMessageModal = document.getElementById("new-message-modal");
        const modalCloseBtn = document.querySelector(".close-btn");
        const recipientList = document.querySelector(".recipient-list");

        newMessageBtn.addEventListener("click", async () => {
          newMessageModal.style.display = "block";

          // Load participants for modal
          const participants = await ChatService.getChatParticipants();
          recipientList.innerHTML = "";

          if (participants.length === 0) {
            recipientList.innerHTML =
              '<div class="no-recipients">No recipients available</div>';
            return;
          }

          participants.forEach((participant) => {
            const li = document.createElement("li");
            li.dataset.participantId = participant.id;
            li.dataset.name = participant.name;
            li.dataset.type = participant.type;
            li.dataset.studentName = participant.studentName || "";
            li.dataset.classroomName = participant.classroomName || "";

            li.innerHTML = `
                <span class="recipient-name">${participant.name}</span>
                <span class="recipient-info">
                    ${
                      participant.type === "teacher"
                        ? `Teacher - ${participant.classroomName}`
                        : `Parent - ${participant.studentName}'s parent`
                    }
                </span>
            `;

            recipientList.appendChild(li);
          });

          // Add click listeners to modal recipients
          recipientList.querySelectorAll("li").forEach((item) => {
            item.addEventListener("click", async () => {
              const participantId = item.dataset.participantId;
              const participantName = item.dataset.name;
              const participantType = item.dataset.type;
              const studentName = item.dataset.studentName;
              const classroomName = item.dataset.classroomName;

              const chatId = await ChatService.getOrCreateChatId(participantId);

              // Find and click the corresponding chat item
              const chatItem = document.querySelector(
                `.chat-item[data-participant-id="${participantId}"]`,
              );
              if (chatItem) {
                chatItem.click();
              } else {
                // If chat item doesn't exist yet, reload chat list
                await ChatService.loadChatList();
                const newChatItem = document.querySelector(
                  `.chat-item[data-participant-id="${participantId}"]`,
                );
                if (newChatItem) newChatItem.click();
              }

              newMessageModal.style.display = "none";
            });
          });
        });

        modalCloseBtn.addEventListener("click", () => {
          newMessageModal.style.display = "none";
        });

        window.addEventListener("click", (e) => {
          if (e.target === newMessageModal) {
            newMessageModal.style.display = "none";
          }
        });
      });
    </script>

    <style>
      /* Additional styles for loading states */
      .loading-chats,
      .loading-recipients {
        text-align: center;
        padding: 20px;
        color: #666;
        font-style: italic;
      }

      .no-chats,
      .no-recipients {
        text-align: center;
        padding: 20px;
        color: #666;
      }

      .welcome-message {
        text-align: center;
        padding: 60px 20px;
        color: #666;
      }

      .welcome-message i {
        font-size: 3rem;
        color: #3498db;
        margin-bottom: 15px;
      }

      .welcome-message h3 {
        margin-bottom: 10px;
        color: #2c3e50;
      }

      .no-messages {
        text-align: center;
        padding: 40px 20px;
        color: #666;
        font-style: italic;
      }

      /* Unread badge styles */
      .unread-badge {
        position: absolute;
        top: 12px;
        right: 15px;
        background: #e74c3c;
        color: white;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        font-size: 12px;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .chat-item {
        position: relative;
      }

      .chat-info {
        flex: 1;
        min-width: 0;
      }
    </style>
  </body>
</html>
